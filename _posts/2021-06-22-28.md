---
title: "[Make] make 할 때 컴파일 속도 향상법(make -j)"
date: 2021-06-22 17:53:00 +0900
categories: ["Etc"]
tags: [etc, make]     # TAG names should always be lowercase
---

# `make` 컴파일 속도 향상

## `make` 컴파일 속도 높이는 방법

리눅스에서 프로그래밍을 하는 개발자라면 `make` 명령어를 사용할 일이 많다.

좋은 스펙의 서버에서 작업을 하더라도 컴파일 할 때 그냥 `make clean; make` 때리고 컴파일이 끝나길 하염없이 기다리는 경우가 있는데,

병렬처리를 통해 컴파일 속도를 획기적으로 높일 수 있는 옵션인 `-j` 를 이용하면 신세계를 맛볼 수 있다.

## `make` 병렬처리 옵션 `-j` 사용법

```shell
-j [jobs], --jobs[=jobs]
    동시에 실행할 작업의 수를 지정한다.
    둘 이상의 -j 옵션이 있는 경우 마지막 옵션이 적용된다.
    -j 옵션이 인수 없이 제공된 경우 make는 동시에 실행할 수 있는 작업 수를 제한하지 않는다.
```

`make -j` 뒤에 동시 실행할 작업의 수를 숫자로 주면 된다.

인수로 주어진 숫자만큼 프로세스가 생성된다고 보면 될 것 같다.

즉, `make -j 8` 로 수행 시, 8개의 프로세스가 생성되어 병렬로 컴파일  한다.

그럼 내 서버에서는 프로세스 숫자를 얼마나 주는 게 좋을까?

아래 예시를 통해서 확인해보자. 

## 사용 예시

### `-j` 옵션 *없이* 수행

진행 중인 프로젝트 소스를 `make` 에 별다른 옵션을 주지 않고 컴파일해보았다.

`time` 명령어를 이용하여 `time make` 로 수행하면 `make` 명령어의 수행 시간을 측정할 수 있다.

![make 수행 시간1](https://github.com/lyw1217/TIL/raw/main/Make/images/make_j_1.png)

약 *1분 31*초가 걸렸다.

### `-j` 옵션과 *함께* 수행

`nproc` 명령어는 사용 가능한 프로세싱 유닛의 숫자를 출력한다.

테스트 서버의 `nproc` 명령어 결과는 *32* 로 32개의 프로세싱 유닛이 사용 가능하다.

그렇다면 **32**개의 프로세스를 전부 활용하여 컴파일하면 얼마나 빠를지 아래와 같이 옵션을 주어서 수행해보자.

```shell
make -j `nproc`
```

수행 결과는 아래와 같다.

![make 수행 시간2](https://github.com/lyw1217/TIL/raw/main/Make/images/make_j_2.png)

약 *17초* 로, 무려 1분 14초(약 _*81 %*_) 감축되었다.

### 생각해볼 내용

`make -j 8` 로 컴파일하면 수행 시간은 아래와 같다.

![make 수행 시간3](https://github.com/lyw1217/TIL/raw/main/Make/images/make_j_3.png)

약 21초로 24개의 프로세싱 유닛 차이에 비하면 시간 차이는 크게 나지 않는데, 정확한 이유는 잘 모르겠다.

혹시 다른 작업이 병행되고 있는 서버에서 컴파일을 진행한다면, 프로세스를 많이 생성하는 것보다 적당히 생성해서 무리가 가지 않게끔 적당한 숫자를 임의부여 하는 것도 괜찮은 방법처럼 보인다.

## 주의사항

병렬 처리에 따른 의존성 문제가 발생할 수 있다. 이는 Makefile 을 작성할 때 필수적으로 확인하여야 하는 부분이므로 주의해야 한다.

## 참고 자료

- [make(1) - Linux man page](https://linux.die.net/man/1/make)